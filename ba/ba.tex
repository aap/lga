\documentclass[12pt,a4paper,normalheadings]{scrartcl}
\usepackage[a4paper,top=3cm, bottom=3cm, left=4cm, right=3cm]{geometry}

\usepackage{polyglossia}
\defaultfontfeatures{Mapping=tex-text}
\setmainlanguage{german}
\setotherlanguage[variant=ancient]{greek}
\input{$HOME/griechisch/greektokens.tex}
\setmainfont{Junicode}
\newfontfamily\greekfont{GFS Neohellenic}

\usepackage{setspace}
\usepackage{calc}

\usepackage{enumitem}
\setlist{parsep=0pt,listparindent=\parindent}

\usepackage[backend=bibtex,style=authoryear,maxcitenames=1,language=german]{biblatex}
\bibliography{ba}

%\usepackage[texcoord,gridunit=cm]{showframe}

\newcommand{\up}[1]{\textsuperscript{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ur}[1]{\up{\ref{#1}}}
\def\rek#1{*\textit{#1}}
\def\bel#1{\textit{#1}}
\def\tt#1{\texttt{#1}}

\begin{document}

\section{Einleitung}

Ziel dieser Arbeit ist es, ein Program zu entwickeln,
das Lautgesetze auf Wörter anwendet,
und die Lautgesetze vom Urindogermanischen in die altgriechischen Dialekte
zu sammeln und zu sortieren.

Das junggrammatische Postulat der Ausnahmslosigkeit der Lautgesetze,
das fordert, dass Lautgesetze wie mechanisch ablaufen,
wirkt sehr einladend,
tatsächlich einen Mechanismus zu entwickeln,
der die Anwendung von Lautgesetzen simuliert.
Im 19. Jh. war dies natürlich unmöglich,
aber trotz der Computerrevolution des 20. Jh. hat sich offenbar
noch niemand daran gemacht,
diese eigentlich sehr naheliegenden Idee zu verwirklichen.

Das hier besprochene Programm \tt{lga} ist
der Nachfolger eines Prototyps (komplett in \tt{sed} geschrieben),
der primitiver war und einige Mängel aufzeigte.
Ebenso ist aber \tt{lga} nur als Prototyp
für ein elaborierteres Programm zu verstehen.
Im Laufe der Arbeit wird sich herausstellen,
welche Probleme, Mängel und weiteren Anforderungen es gibt,
die man in einer nächsten Version angehen müsste.

Im ersten Teil dieser Arbeit wird \tt{lga}
in seinen Designideen und in seiner Funktionsweise vorgestellt.
Im zweiten Teil wird \tt{lga} benutzt,
um die Lautentwicklung vom Urindogermanischen ins Altgriechische zu modellieren.

\section{lga}

\subsection{Vorüberlegungen}

Wenn ein Lautgesetzt wirkt,
wird ein Laut (oder mehrere) durch einen anderen ersetzt.
Da man Laute phonetisch notieren kann,
kann man auch ein Lautgesetz durch Ersetzung
von einem Zeichen durch ein anderes beschreiben.

Da Lautwandel meist durch die Lautumgebung bedingt ist
und sich oft nicht nur ein Laut sondern Lautgruppen verändern
(bspw. Stimmloswerdung von stimmhaften Lauten),
ist es sinnvoll,
eine Sprache zu entwicklen,
die Lautgesetze kompakt beschreiben
und von einem Computerprogramm verstanden werden kann.
Eine naheliegende Wahl ist daher eine Form von \emph{regulären Ausdrücken},
die in vielen Programmen implementiert und weithin bekannt sind.
Reguläre Ausdrücke sind zwar für diesen Zweck nicht perfekt geeignet,
aber für einen Prototyp ausreichend.
Wenn sich gezeigt hat,
welche Defizite reguläre Ausdrücke für diesen Anwendungsfall haben,
wird man eine besser geeignete Sprache entwickeln und implementieren können.

Als Programmiersprache wird CHICKEN -- eine Implementation von Scheme --
verwendet (\tt{http://www.call-cc.org/}).

\subsection{Reguläre Ausdrücke}

Hier eine (informelle)
Beschreibung der hier verwendeten Untermenge regulärer Ausdrücke.
Die vollständige Dokumentation für die \tt{irregex} Engine für
CHICKEN findet sich auf
\tt{http://wiki.call-cc.org/man/4/Unit\%20irregex}

Die grundlegende Funktion von regulären Ausdrücken ist das
Finden (engl. \bel{match}) von Zeichenketten (String) anhand eines Musters.
Der gematchte Text kann dann durch einen anderen ersetzt werden,
der Teile des Matches wieder aufnehmen kann.

Ein regulärer Ausdruck matcht einen String aus einem Alphabet;
hier die Menge der Unicode \emph{Codepoints} (nicht
der \emph{Grapheme}, die aus mehreren Codepoints bestehen können).

Ein Zeichen des Alphabets, das kein Metazeichen ist (dazu unten),
matcht sich selbst.
Metazeichen verlieren ihre spezielle Funktion,
wenn ihnen ein Backslash \tt{\textbackslash} vorangeht.
Der Ausdruck \tt{foo} matcht also den String \tt{foo}
(und auch das \tt{foo} in \tt{foobar}).

Der Punkt \tt{.} matcht ein beliebiges Zeichen.
Der Ausdruck \tt{...} matcht also alle Strings mit drei Zeichen,
\tt{\textbackslash.\textbackslash.\textbackslash.} matcht drei Punkte.

Eine in eckigen Klammern stehende Menge an Zeichen matcht eins dieser Zeichen,
oder alle außer dieser Zeichen,
wenn das erste Zeichen ein Zirkumflex \tt{\^{}} ist.
Dabei können auch Zeichenbereiche mit Bindestrich angegeben werden.
\tt{[abc]} matcht also \tt{a}, \tt{b} oder \tt{c},
\tt{[\^{}abc]} alle Zeichen außer \tt{a}, \tt{b} und \tt{c}.
Alternativ hätte man auch \tt{[a-c]} schreiben können.

Der Zirkumflex \tt{\^{}} und das Dollarzeichen \tt{\$}
matchen den Anfang bzw. das Ende einer Zeile.
\tt{\^{}foo} matcht also \tt{foo} am Anfang der Zeile,
\tt{bar\$} matcht \tt{bar} am Ende der Zeile
und \tt{\^{}quux\$} die Zeile, die nur \tt{quux} enthält.
Da in \tt{lga} jedes Wort in einer eigenen Zeile steht,
kann man die Zeichen für den Anfang bzw. das Ende des Wortes benutzen.

\tt{?}, \tt{*} und \tt{+} sind Quantoren
und matchen, was ihnen vorangeht, null oder einmal, null bis unendlich mal
und ein bis unendlich mal.
Der Ausdruck \tt{.?[a-d]*x+} z.B.
matcht optional ein beliebiges Zeichen, dann eins der Zeichen \tt{a-d}
null bis unendlich mal und schließlich mindestens ein \tt{x}.

Mit Klammern \tt{()} werden analog zur mathematischen Notation
Matches enger gruppiert.
So würde \tt{[ab]c+} \tt{a} oder \tt{b} und dann mindestens ein
\tt{c} matchen (also z.B. \tt{accc} oder \tt{bc}).
\tt{([ab]c)+} dagegen matcht \tt{[ab]c} mindestens einmal
(also z.B. \tt{acbcbc}).

Neben ihrer Gruppierungsfunktion werden die Submatches innerhalb
der Klammern für die Ersetzung gespeichert.
\tt{([0-9]+)foo([0-9]+)} würde also zwei Zahlen und \tt{foo} dazwischen
matchen.
Die Zahlen wären dann in den submatchtes \tt{1} und \tt{2} gespeichert
und können im Ersetzungstext wieder aufgegriffen werden.

Mit dem senkrechten Strich \tt{e0|e1} wird \tt{e0}
oder \tt{e1} gematcht (der Senkrechtstrich hat die niedrigste Präzedenz).
\tt{foo|bar+} matcht also \tt{foo} oder mindestens ein \tt{bar}.
\tt{(foo|bar)+} dagegen matcht mindestens ein \tt{foo} oder \tt{bar}.

\subsection{Funktionsweise}

Im Kern arbeitet \tt{lga} mit einer Liste von Wörtern
und einer Liste von Lautgesetzen
(in der Form von Textersetzung durch reguläre Ausdrücke)
und wendet der Reihe nach alle Lautgesetze auf die Liste der Wörter an.
Das Resultat sind die Wörter nach Anwendung aller Lautgesetze.

Die Liste der Lautgesetze aber hängt davon ab,
von welcher in welche Sprache die Wörter transformiert werden sollen
und wird aus einem \emph{Baum} von Lautgesetzen und einem
zugehörigen Sprachstammbaum generiert.

Die Liste der Wörter wird vorher durch eine weitere Liste von Regeln,
die von der Ausgangssprache abhängt,
von ihrer graphematischen Form in eine interne phonetische gebracht
(was natürlich eine eindeutige Graphie voraussetzt)
und am Ende durch noch eine Liste von Regeln,
die von der Zielsprache abhängig ist,
wieder in eine graphematische Darstellung gebracht.

Die Funktion \tt{(run-list from to words)}
generiert die drei Listen von Regeln anhand der Sprachen \tt{from} und \tt{to},
macht aus der Liste von Wörtern \tt{words} aus Effizienzgründen einen
einzigen String,
in dem jedes Element von \tt{words} in einer eigenen Zeile steht,
wendet darauf die drei Regellisten an,
und gibt das Ergebnis aus.

Zunächst wird mit der Funktion \tt{(make-path tree start end)} anhand
eines Sprachstammbaums \tt{tree}
eine Liste aller Sprachen von der Ausgangs- zur Zielsprache generiert.
Der Aufruf \tt{(make-path lang-tree 'uridg 'lesb)} würde bspw.
die Liste \tt{(uridg urgr uraiol lesb)} erzeugen.

Der Sprachstammbaum (gespeichert in der globalen Variable \tt{lang-tree})
definiert das Verwandtschaftsverhältnis von Sprachen.
Wenn eine Sprache keine Untersprachen hat,
ist sie (in Scheme-Terminologie) ein Symbol
(also hat z.B. \tt{myk} keine Abkömmlinge).
Hat eine Sprache Untersprachen,
ist sie eine Liste, dessen erstes Element ein Symbol für die Sprache selber ist;
die weiteren Elemente sind Untersprachen (wiederum Symbole oder Listen).
Ein vereinfachter Stammbaum könnte also bswp. folgendermaßen aussehen:
\begin{verbatim}
(uridg (urgr (urark myk ark kypr)
             (uraiol thess boiot lesb)
             (urwgr nwgr dor)
             (urion (aion ion) (aatt att))))
\end{verbatim}
Es sei angemerkt,
dass die so beschriebene Verhältnisse nicht streng als Verwandtschaft
interpretiert werden sollten.
Urion. mag zwar eine Ursprache gewesen sein,
aber auch nach der Aufspaltung von att. und ion. teilen sie
noch gewisse Entwicklungen.
Ebenso gibt es gemeingriechische Entwicklung die nach-urgriechisch sind.
Eine präzisere Trennung von Verwandtschaft und ``Sprachgruppen''
würde aber das Modell möglicherweise zu sehr verkomplizieren.
Die beste Möglichkeit ist es womöglich,
auf die Vorsilbe \textit{ur-} zu verzichten und bspw. \tt{gr}
gleichermaßen für urgriechisch und gemeingriechisch zu verwenden.

\section{Lautentwicklung des Altgriechischen}

\printbibliography

\end{document}
