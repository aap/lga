\documentclass[12pt,a4paper,normalheadings]{scrartcl}
\usepackage[a4paper,top=3cm, bottom=3cm, left=4cm, right=3cm]{geometry}

\usepackage{polyglossia}
\defaultfontfeatures{Mapping=tex-text}
\setmainlanguage{german}
\setotherlanguage[variant=ancient]{greek}
\input{$HOME/griechisch/greektokens.tex}
\setmainfont{Junicode}
\setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}
%\setmonofont{Courier New}
\newfontfamily\greekfont{GFS Neohellenic}

\usepackage{setspace}
\usepackage{calc}

\usepackage{enumitem}
\setlist{parsep=0pt,listparindent=\parindent}

\usepackage[backend=bibtex,style=authoryear,maxcitenames=1,language=german]{biblatex}
\bibliography{ba}

%\usepackage[texcoord,gridunit=cm]{showframe}

\newcommand{\up}[1]{\textsuperscript{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ur}[1]{\up{\ref{#1}}}
\def\rek#1{*\textit{#1}}
\def\bel#1{\textit{#1}}
\def\tt#1{\texttt{#1}}

\begin{document}
\onehalfspacing

\section{Einleitung}

Ziel dieser Arbeit ist es, ein Program zu entwickeln,
das Lautgesetze auf Wörter anwendet,
und die Lautgesetze vom Urindogermanischen in die altgriechischen Dialekte
zu sammeln und zu sortieren.

Das junggrammatische Postulat der Ausnahmslosigkeit der Lautgesetze,
das fordert, dass Lautgesetze wie mechanisch ablaufen,
wirkt sehr einladend,
tatsächlich einen Mechanismus zu entwickeln,
der die Anwendung von Lautgesetzen simuliert.
Im 19. Jh. war dies natürlich unmöglich,
aber trotz der Computerrevolution des 20. Jh. hat sich offenbar
noch niemand daran gemacht,
diese eigentlich sehr naheliegenden Idee zu verwirklichen.

Das hier besprochene Programm \tt{lga} ist
der Nachfolger eines Prototyps (komplett in \tt{sed} geschrieben),
der primitiver war und einige Mängel aufzeigte.
Ebenso ist aber \tt{lga} nur als Prototyp
für ein elaborierteres Programm zu verstehen.
Im Laufe der Arbeit wird sich herausstellen,
welche Probleme, Mängel und weiteren Anforderungen es gibt,
die man in einer nächsten Version angehen müsste.

Im ersten Teil dieser Arbeit wird \tt{lga}
in seinen Designideen und in seiner Funktionsweise vorgestellt.
Im zweiten Teil wird \tt{lga} benutzt,
um die Lautentwicklung vom Urindogermanischen ins Altgriechische zu modellieren.

\section{lga}

\subsection{Vorüberlegungen}

Wenn ein Lautgesetzt wirkt,
wird ein Laut (oder mehrere) durch einen anderen ersetzt.
Da man Laute phonetisch notieren kann,
kann man auch ein Lautgesetz durch Ersetzung
von einem Zeichen durch ein anderes beschreiben.

Da Lautwandel meist durch die Lautumgebung bedingt ist
und sich oft nicht nur ein Laut sondern Lautgruppen verändern
(bspw. Stimmloswerdung von stimmhaften Lauten),
ist es sinnvoll,
eine Sprache zu entwicklen,
die Lautgesetze kompakt beschreiben
und von einem Computerprogramm verstanden werden kann.
Eine naheliegende Wahl ist daher eine Form von \emph{regulären Ausdrücken},
die in vielen Programmen implementiert und weithin bekannt sind.
Reguläre Ausdrücke sind zwar für diesen Zweck nicht perfekt geeignet,
aber für einen Prototyp ausreichend.
Wenn sich gezeigt hat,
welche Defizite reguläre Ausdrücke für diesen Anwendungsfall haben,
wird man eine besser geeignete Sprache entwickeln und implementieren können.

Als Programmiersprache wird CHICKEN -- eine Implementation von Scheme --
verwendet (\tt{http://www.call-cc.org/}).

\subsection{Reguläre Ausdrücke}

Hier eine (informelle)
Beschreibung der hier verwendeten Untermenge regulärer Ausdrücke.
Die vollständige Dokumentation für die \tt{irregex}-Engine für
CHICKEN findet sich auf
\tt{http://wiki.call-cc.org/man/4/Unit\%20irregex}

Die grundlegende Funktion von regulären Ausdrücken ist das
Finden (engl. \bel{match}) von Zeichenketten (String) anhand eines Musters.
Der gematchte Text kann dann durch einen anderen ersetzt werden,
der Teile des Matches wieder aufnehmen kann.

Ein regulärer Ausdruck matcht einen String aus einem Alphabet;
hier die Menge der Unicode \emph{Codepoints} (nicht
der \emph{Grapheme}, die aus mehreren Codepoints bestehen können).

Ein Zeichen des Alphabets, das kein Metazeichen ist (dazu unten),
matcht sich selbst.
Metazeichen verlieren ihre spezielle Funktion,
wenn ihnen ein Backslash \tt{\textbackslash} vorangeht.
Der Ausdruck \tt{foo} matcht also den String \tt{foo}
(und auch das \tt{foo} in \tt{foobar}).

Der Punkt \tt{.} matcht ein beliebiges Zeichen.
Der Ausdruck \tt{...} matcht also alle Strings mit drei Zeichen,
\tt{\textbackslash.\textbackslash.\textbackslash.} matcht drei Punkte.

Eine in eckigen Klammern stehende Menge an Zeichen matcht eins dieser Zeichen,
oder alle außer dieser Zeichen,
wenn das erste Zeichen ein Zirkumflex \tt{\^{}} ist.
Dabei können auch Zeichenbereiche mit Bindestrich angegeben werden.
\tt{[abc]} matcht also \tt{a}, \tt{b} oder \tt{c},
\tt{[\^{}abc]} alle Zeichen außer \tt{a}, \tt{b} und \tt{c}.
Alternativ hätte man auch \tt{[a-c]} schreiben können.

Der Zirkumflex \tt{\^{}} und das Dollarzeichen \tt{\$}
matchen den Anfang bzw. das Ende einer Zeile.
\tt{\^{}foo} matcht also \tt{foo} am Anfang der Zeile,
\tt{bar\$} matcht \tt{bar} am Ende der Zeile
und \tt{\^{}quux\$} die Zeile, die nur \tt{quux} enthält.
Da in \tt{lga} jedes Wort in einer eigenen Zeile steht,
kann man die Zeichen für den Anfang bzw. das Ende des Wortes benutzen.

\tt{?}, \tt{*} und \tt{+} sind Quantoren
und matchen, was ihnen vorangeht, null oder einmal, null bis unendlich mal
und ein bis unendlich mal.
Der Ausdruck \tt{.?[a-d]*x+} z.B.
matcht optional ein beliebiges Zeichen, dann eins der Zeichen \tt{a-d}
null bis unendlich mal und schließlich mindestens ein \tt{x}.

Mit Klammern \tt{()} werden analog zur mathematischen Notation
Matches enger gruppiert.
So würde \tt{[ab]c+} \tt{a} oder \tt{b} und dann mindestens ein
\tt{c} matchen (also z.B. \tt{accc} oder \tt{bc}).
\tt{([ab]c)+} dagegen matcht \tt{[ab]c} mindestens einmal
(also z.B. \tt{acbcbc}).

Neben ihrer Gruppierungsfunktion werden die Submatches innerhalb
der Klammern für die Ersetzung gespeichert.
\tt{([0-9]+)foo([0-9]+)} würde also zwei Zahlen und \tt{foo} dazwischen
matchen.
Die Zahlen wären dann in den submatchtes \tt{1} und \tt{2} gespeichert
und können im Ersetzungstext wieder aufgegriffen werden.

Mit dem senkrechten Strich \tt{e0|e1} wird \tt{e0}
oder \tt{e1} gematcht (der Senkrechtstrich hat die niedrigste Präzedenz).
\tt{foo|bar+} matcht also \tt{foo} oder mindestens ein \tt{bar}.
\tt{(foo|bar)+} dagegen matcht mindestens ein \tt{foo} oder \tt{bar}.

\subsection{Funktionsweise}

Im Kern arbeitet \tt{lga} mit einer Liste von Wörtern
und einer Liste von Lautgesetzen
(in der Form von Textersetzung durch reguläre Ausdrücke)
und wendet der Reihe nach alle Lautgesetze auf die Liste der Wörter an.
Das Resultat sind die Wörter nach Anwendung aller Lautgesetze.

Die Liste der Lautgesetze aber hängt davon ab,
von welcher in welche Sprache die Wörter transformiert werden sollen
und wird aus einem \emph{Baum} von Lautgesetzen und einem
zugehörigen Sprachstammbaum generiert.

Die Liste der Wörter wird vorher durch eine weitere Liste von Regeln,
die von der Ausgangssprache abhängt,
von ihrer graphematischen Form in eine interne phonetische gebracht
(was natürlich eine eindeutige Graphie voraussetzt)
und am Ende durch noch eine Liste von Regeln,
die von der Zielsprache abhängig ist,
wieder in eine graphematische Darstellung gebracht.

Die Funktion \tt{(run-list from to words)}
generiert die drei Listen von Regeln anhand der Sprachen \tt{from} und \tt{to},
macht aus der Liste von Wörtern \tt{words} aus Effizienzgründen einen
einzigen String,
in dem jedes Element von \tt{words} in einer eigenen Zeile steht,
wendet darauf die drei Regellisten an,
und gibt das Ergebnis aus.

Zunächst wird mit der Funktion \tt{(make-path tree start end)} anhand
eines Sprachstammbaums \tt{tree}
eine Liste aller Sprachen von der Ausgangs- zur Zielsprache generiert.
Der Aufruf \tt{(make-path lang-tree 'uridg 'lesb)} würde bspw.
die Liste \tt{(uridg urgr uraiol lesb)} erzeugen.

Der Sprachstammbaum (gespeichert in der globalen Variable \tt{lang-tree})
definiert das Verwandtschaftsverhältnis von Sprachen.
Wenn eine Sprache keine Untersprachen hat,
ist sie (in Scheme-Terminologie) ein Symbol
(also hat z.B. \tt{myk} keine Abkömmlinge).
Hat eine Sprache Untersprachen,
ist sie eine Liste, dessen erstes Element ein Symbol für die Sprache selber ist;
die weiteren Elemente sind Untersprachen (wiederum Symbole oder Listen).
Ein vereinfachter Stammbaum könnte also bspw. folgendermaßen aussehen:
\begin{verbatim}
(uridg (urgr (urark myk ark kypr)
             (uraiol thess boiot lesb)
             (urwgr nwgr dor)
             (urion (aion ion) (aatt att))))
\end{verbatim}
Es sei angemerkt,
dass die so beschriebenen Verhältnisse nicht streng als Verwandtschaft
interpretiert werden sollten.
Urion. mag zwar eine Ursprache gewesen sein,
aber auch nach der Aufspaltung von att. und ion. teilen sie
noch gewisse Entwicklungen.
Ebenso gibt es gemeingriechische Entwicklung die nach-urgriechisch sind.
Eine präzisere Trennung von Verwandtschaft und ``Sprachgruppen''
würde aber das Modell möglicherweise zu sehr verkomplizieren.
Die beste Möglichkeit ist es womöglich,
auf die Vorsilbe \textit{ur-} zu verzichten und bspw. \tt{gr}
gleichermaßen für urgriechisch und gemeingriechisch zu verwenden.

Der Lautgesetzbaum ist eine Liste von vier möglichen Elementen, nämlich
Funktionen, die einen String als Argument nehmen und einen String zurückgeben
(also Funktionen, die Lautgesetze anwenden),
Symbole, die eine Sprachstufe markieren,
und zwei Arten von Listen des Typs \tt{(br/sub lang-lst rule-tree)},
deren zweites Element eine Liste von Sprachen ist,
für die sie gelten (bzw. nicht gelten, wenn das erste Element \tt{not} ist),
und deren drittes Element ein weiterer Lautgesetzbaum ist.
\tt{br} (für \emph{branch}) leitet einen neuen Sprachzweig ein,
der durch \tt{rule-tree} definiert ist
(d.h. dass alle Regeln nach einem erfolgreichen \tt{br} ignoriert werden).
\tt{sub} (für \emph{subrules}) funktioniert ähnlich,
macht aber nach Abarbeitung von \tt{rule-tree}
nach der Regel weiter.
Dies impliziert,
dass es sich hier bei \tt{rule-tree} nicht um einen echten Baum handelt.
\tt{sub} ist nur dazu gedacht eine Liste von Lautgesetzen bedingt anzuwenden.
Im Griechischen ist dies besonders nützlich,
da zwar alle Dialekte ähnliche Entwicklungen machen,
diese sich aber im einzelnen unterscheiden.
Mit \tt{sub} kann man einfach Regeln für bestimme Dialekte oder
Dialektgruppen definieren ohne für jeden Dialekt einen eigenen Sprachzweig
haben zu müssen.

Die Funktion \tt{(make-rules tree path)}
gibt anhand des Lautgesetz\emph{baums} \tt{tree} eine \emph{Liste}
von Lautgesetzen zurück,
die die Sprachentwicklung in \tt{path} (von \tt{make-path} erzeugt, s.o.)
reflektiert.
Von \tt{(apply-rules rules words)} wird dann diese Liste \tt{rules}
auf die Wörter \tt{words} angewandt.

Die Lautgesetzfunktionen werden von der Funktion \tt{(s pattern . subst)}
erzeugt,
die aus einem String \tt{pattern} einen regulären Ausdruck macht
und eine Funktion zurückgibt,
die \tt{irregex-replace/all} auf diesen regulären Ausdruck
und die Ersetzungen in der Liste \tt{subst} anwendet.
Matcht der reguläre Ausdruck einen Teil der Eingabe,
wird diese durch \tt{subst} ersetzt,
dessen Elemente Strings, Zahlen als Indizes der Submatches, sowie
Funktionen, die anhand eines Matches Strings zurückgeben, sind.
\tt{(irregex-replace/all "(foo)(bar)" "foobar" 2 (lambda (m)
    (string-reverse (irregex-match-substring m 1))) "quux")}
z.B. würde den String \tt{"foobar"} durch \tt{"baroofquux"} ersetzen.

Die oben beschriebenen regulären Ausdrücke
sind für die Modellierung von Laugesetzen nicht ausreichend.
Neben anderen Unzulänglichkeiten,
die sich im Laufe der Arbeit herausstellen werden,
gibt es eindeutig Probleme, mit Lautklassen umzugehen,
und noch allgemeiner, Laute durch Zeichen zu kodieren.

Wenn jeder Laut durch genau ein Zeichen bzw. einen Unicode Codepoint kodiert wird,
gibt es der Lautkodierung keine Probleme.
Da es allerdings sinnvoll ist,
einige Laute mit mehreren Codepoints zu kodieren,
kann es zu Problemen kommen.
Will man bspw. ein Lautgesetz \tt{(s "b" "p")} formulieren,
so hätte dies die Nebenwirkung,
dass auch \tt{bʰ} zu \tt{pʰ} würde,
was im allgemeinen Fall unerwünscht ist.
Wenn man Laute wie \bel{bʰ} oder \bel{gʷ} mit einem einzigen Codepoint
repräsentieren würde,
hätte man dieses Problem natürlich zwar nicht,
jedoch bietet Unicode für solche Vorhaben keine definierten Codepoints.
Dafür müsste man die Private Use Area benutzen,
wodurch die Kodierung jedoch von der Schriftart abhängig wird:
eine unschöne Lösung.
In der hier entwickelten Version von \tt{lga} wird das Problem nicht gelöst.
Stattdessen müssen die Lautgesetze vorläufig
besonders vorsichtig formuliert werden,
der obere Fall also als \tt{(s "b([\^{}ʰ]?)" "p" 1)}.

Bei der Formulierung von Lautgesetzen ist es ferner sinnvoll,
Laute in Lautklassen zusammenzufassen um eine konzise
und leicht abstrahierende Darstellung zu haben.
Der POSIX Standard definiert zwar Zeichenklassen wie \tt{[:digit:]}
für Ziffern oder \tt{[:lower:]} für Kleinbuchstaben,
aber die Bedürfnisse, die man als Linguist hat,
sind damit nicht abgedeckt,
da sich zur Laufzeit Zeichenklassen weder neu definieren noch verändern lassen.
Dieses Problem lässt sich vorläufig lösen,
indem die regulären Ausdrücke,
bevor sie von \tt{string->irregex} in eine interne Form kompiliert werden,
noch verändert werden,
so dass die tatsächlich im Quelltext vorkommenden regulären Ausdrücke
erst zu echten regulären Ausdrücken verarbeitet werden,
die von der \tt{irregex}-Engine verstanden werden.
Konkret funktioniert dies so,
dass in einer assoziativen Liste Lautklassennamen (als Symbole)
mit Strings assoziiert werden
und bei der Vorbearbeitung der regulären Ausdrücke
Strings der Form \tt{<lautklassenname>} durch den mit dem Symbol
\tt{lautklassenname} assoziierten String ersetzt werden.
Die Funktion \tt{(set-class key value)} assoziiert den Namen \tt{key}
mit dem String \tt{value} und \tt{(l key)} (kurz für \emph{lookup})
findet den zu \tt{key} passenden String in der assoziativen Liste.

So kann man bspw. mit \tt{(set-class 'kurz-vok "a|e|i|o|u")} und
\tt{(set-class 'lang-vok "ā|ē|ī|ō|ū")} Kurz- und Langvokale definieren,
mit \tt{(set-class 'vok (s+ (l 'kurz-vok) "|" (l 'lang-vok)))} dann die Menge
aller Vokale
(\tt{s+} ist eine Abkürzung für \tt{string-append} zum Verketten von Strings)
und diese in einem Lautgesetz wie \tt{(s "<vok>" "a")} verwenden.

Die Lautklassen sind jedoch zur Laufzeit nicht vernünftig veränderbar,
da sie zur Zeit der Auswertung von \tt{s} in den regulären Ausdruck
eingefügt werden,
man die Definition aber wohl am ehesten aus dem Lautgesetzbaum heraus
verändern wollen würde.
Hier wird nur eine neuentwickelte Lautgesetzengine wirklich
Abhilfe schaffen können.

Es gibt jedoch noch ein weiteres Problem.
So kann man nicht ohne weiteres z.B. einen Langvokal durch seinen
entsprechenden Kurzvokal oder einen silbischen durch sein unsilbisches
Pendant ersetzen.
Beispiele für solche Vorgänge gibt es genug und es ist eine Methode notwendig,
mit der man diese Fälle unkompliziert ausdrücken kann.
In einer späteren Version wäre vielleicht eine Ersetzung wie
\tt{(s "<lang-vok>" "<kurz-vok>")} wünschenswert,
in der aktuellen Version können jedoch auch Funktionen,
die auf Submatches angewandt werden, denselben Effekt erzielen.
Als Ersetzungsargumente kann man an \tt{irregex-replace/all}
neben Strings und Zahlen, die das entsprechende Submatch bezeichnen,
auch Funktionen übergeben,
die auf das aktuelle Match angewandt werden und einen String zurückgeben.
Um also z.B. einen Langvokal in ein Kurzvokal zu verwandeln,
braucht es nur eine Funktion,
die auf ein Submatch eine Reihe von regulären Ausdrücken anwendet
und das Ergebnis zurückgibt.
Eine Funktion, die reguläre Ausdrücke auf einen String anwendet,
gibt es ja schon: \tt{apply-rules}.
Diese wird von der Funktion \tt{(match-rulelist rules)} benutzt,
die eine Liste von Ersetzungsfunktionen \tt{rules}
auf ein Submatch anwendet.
Dazu gibt sie eine Funktion zurück,
die einen Submatchindex \tt{i} bindet und eine Funktion zurückgibt,
auf die \tt{irregex-replace/all} angewandt werden kann.
Die Vokalkürzung könnte somit folgendermaßen definiert werden:
\begin{verbatim}
(define kuerzung
  (match-rulelist
    (list (s "ā" "a")
          (s "ē" "e")
          (s "ō" "o")
          (s "ī" "i")
          (s "ū" "u"))))
\end{verbatim}
Ein Lautgesetz, das alle Langvokale kürzt,
könnte dann als \tt{(s "(<lang-vok>)" (kuerzung 1))} formuliert werden.

Die eingangs erwähnten Regellisten zur Umwandlung von einer
graphematisch/phonologischen in eine phonetische und von
einer phonetischen in eine graphematisch/phonologische Darstellung
sind unter ihrem Sprachnamen ebenfalls in
assoziativen Listen abgelegt.

Hiermit ist die Funktionalität von \tt{lga} weitestgehend erläutert.
Eine genauere Beschreibung kann natürlich nur der Quelltext selber liefern.

\section{Lautentwicklung des Altgriechischen}

\printbibliography

\end{document}
