\documentclass[12pt,a4paper,normalheadings]{scrartcl}
\usepackage[a4paper,top=3cm, bottom=3cm, left=4cm, right=3cm]{geometry}

\usepackage{polyglossia}
\defaultfontfeatures{Mapping=tex-text}
\setmainlanguage{german}
\setotherlanguage[variant=ancient]{greek}
\input{$HOME/griechisch/greektokens.tex}
\setmainfont{Junicode}
\setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}
%\setmonofont{Courier New}
\newfontfamily\greekfont{GFS Neohellenic}

\usepackage{setspace}
\usepackage{calc}

\renewcommand{\theparagraph}{\arabic{paragraph}}
\setcounter{secnumdepth}{5}

\newcounter{para}
\newcommand{\mypara}[1]{\vspace{1em}\par\noindent\refstepcounter{para}%
\textbf{\textsf{\thepara}}\enspace\textsf{#1}\quad}

\usepackage{enumitem}
\setlist{parsep=0pt,listparindent=\parindent}

\usepackage[backend=bibtex,style=authoryear,maxcitenames=1,language=german]{biblatex}
\bibliography{ba}

%\usepackage[texcoord,gridunit=cm]{showframe}

\newcommand{\up}[1]{\textsuperscript{#1}}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ur}[1]{\up{\ref{#1}}}
\def\rek#1{*\textit{#1}}
\def\bel#1{\textit{#1}}
\def\tt#1{\texttt{#1}}

\begin{document}
\onehalfspacing

\section{Einleitung}

Ziel dieser Arbeit ist es, ein Program zu entwickeln,
das Lautgesetze auf Wörter anwendet,
und die Lautgesetze vom Urindogermanischen in die altgriechischen Dialekte
zu sammeln und zu sortieren.

Das junggrammatische Postulat der Ausnahmslosigkeit der Lautgesetze,
das fordert, dass Lautgesetze wie mechanisch ablaufen,
wirkt sehr einladend,
tatsächlich einen Mechanismus zu entwickeln,
der die Anwendung von Lautgesetzen simuliert.
Im 19. Jh. war dies natürlich unmöglich,
aber trotz der Computerrevolution des 20. Jh. hat sich offenbar
noch niemand daran gemacht,
diese eigentlich sehr naheliegenden Idee zu verwirklichen.
(TODO: doch, Amir Zeldes ansatzweise)

Eine solche Lautwandelsimulation erfordert,
dass die Lautgesetze präzise und in korrekter Chronologie formuliert werden,
und erlaubt sowohl
selbige Aufstellung ohne großen Aufwand an beliebig vielen Testwörtern
zu überprüfen
als auch belegte Wörter auf ihre Lautgesetzlichkeit hin zu überprüfen.

Das hier vorgestellte Programm \tt{lga} ist
der Nachfolger eines Prototyps (komplett in \tt{sed} geschrieben),
der primitiver war und einige Mängel aufzeigte.
Ebenso ist aber \tt{lga} nur als Prototyp
für ein elaborierteres Programm zu verstehen.
Im Laufe der Arbeit wird sich herausstellen,
welche Probleme, Mängel und weiteren Anforderungen es gibt,
die man in einer nächsten Version angehen müsste.

Im ersten Teil dieser Arbeit wird \tt{lga}
in seinen Designideen und in seiner Funktionsweise vorgestellt.
Im zweiten Teil wird \tt{lga} benutzt,
um die Lautentwicklung vom Urindogermanischen ins Altgriechische zu modellieren.

\section{lga}

\subsection{Vorüberlegungen}

Wenn ein Lautgesetzt wirkt,
wird ein Laut (oder mehrere) durch einen anderen ersetzt.
Da man Laute phonetisch notieren kann,
kann man auch ein Lautgesetz durch Ersetzung
von einem Zeichen durch ein anderes beschreiben.

Da Lautwandel meist durch die Lautumgebung bedingt ist
und sich oft nicht nur ein Laut sondern Lautgruppen verändern
(bspw. Stimmloswerdung von stimmhaften Lauten),
ist es sinnvoll,
eine Sprache zu entwicklen,
die Lautgesetze kompakt beschreiben
und von einem Computerprogramm verstanden werden kann.
Eine naheliegende Wahl ist daher eine Form von \emph{regulären Ausdrücken},
die in vielen Programmen implementiert und weithin bekannt sind.
Reguläre Ausdrücke sind zwar für diesen Zweck nicht perfekt geeignet,
aber für einen Prototyp ausreichend.
Wenn sich gezeigt hat,
welche Defizite reguläre Ausdrücke für diesen Anwendungsfall haben,
wird man eine besser geeignete Sprache entwickeln und implementieren können.

Als Programmiersprache wird CHICKEN -- eine Implementation von Scheme --
verwendet (\tt{http://www.call-cc.org/}).

\subsection{Reguläre Ausdrücke}

Hier eine (informelle)
Beschreibung der hier verwendeten Untermenge regulärer Ausdrücke.
Die vollständige Dokumentation für die \tt{irregex}-Engine für
CHICKEN findet sich auf
\tt{http://wiki.call-cc.org/man/4/Unit\%20irregex}

Die grundlegende Funktion von regulären Ausdrücken ist das
Finden (engl. \bel{match}) von Zeichenketten (String) anhand eines Musters.
Der gematchte Text kann dann durch einen anderen ersetzt werden,
der Teile des Matches wieder aufnehmen kann.

Ein regulärer Ausdruck matcht einen String aus einem Alphabet;
hier die Menge der Unicode \emph{Codepoints} (nicht
der \emph{Grapheme}, die aus mehreren Codepoints bestehen können).

Ein Zeichen des Alphabets, das kein Metazeichen ist (dazu unten),
matcht sich selbst.
Metazeichen verlieren ihre spezielle Funktion,
wenn ihnen ein Backslash \tt{\textbackslash} vorangeht.
Der Ausdruck \tt{foo} matcht also den String \tt{foo}
(und auch das \tt{foo} in \tt{foobar}).

Der Punkt \tt{.} matcht ein beliebiges Zeichen.
Der Ausdruck \tt{...} matcht also alle Strings mit drei Zeichen,
\tt{\textbackslash.\textbackslash.\textbackslash.} matcht drei Punkte.

Eine in eckigen Klammern stehende Menge an Zeichen matcht eins dieser Zeichen,
oder alle außer dieser Zeichen,
wenn das erste Zeichen ein Zirkumflex \tt{\textasciicircum} ist.
Dabei können auch Zeichenbereiche mit Bindestrich angegeben werden.
\tt{[abc]} matcht also \tt{a}, \tt{b} oder \tt{c},
\tt{[\textasciicircum{}abc]} alle Zeichen außer \tt{a}, \tt{b} und \tt{c}.
Alternativ hätte man auch \tt{[a-c]} schreiben können.

Der Zirkumflex \tt{\textasciicircum} und das Dollarzeichen \tt{\$}
matchen den Anfang bzw. das Ende einer Zeile.
\tt{\textasciicircum{}foo} matcht also \tt{foo} am Anfang der Zeile,
\tt{bar\$} matcht \tt{bar} am Ende der Zeile
und \tt{\textasciicircum{}quux\$} die Zeile, die nur \tt{quux} enthält.
Da in \tt{lga} jedes Wort in einer eigenen Zeile steht,
kann man die Zeichen für den Anfang bzw. das Ende des Wortes benutzen.

\tt{?}, \tt{*} und \tt{+} sind Quantoren
und matchen, was ihnen vorangeht, null oder einmal, null bis unendlich mal
und ein bis unendlich mal.
Der Ausdruck \tt{.?[a-d]*x+} z.B.
matcht optional ein beliebiges Zeichen, dann eins der Zeichen \tt{a-d}
null bis unendlich mal und schließlich mindestens ein \tt{x}.

Mit Klammern \tt{()} werden analog zur mathematischen Notation
Matches enger gruppiert.
So würde \tt{[ab]c+} \tt{a} oder \tt{b} und dann mindestens ein
\tt{c} matchen (also z.B. \tt{accc} oder \tt{bc}).
\tt{([ab]c)+} dagegen matcht \tt{[ab]c} mindestens einmal
(also z.B. \tt{acbcbc}).

Neben ihrer Gruppierungsfunktion werden die Submatches innerhalb
der Klammern für die Ersetzung gespeichert.
\tt{([0-9]+)foo([0-9]+)} würde also zwei Zahlen und \tt{foo} dazwischen
matchen.
Die Zahlen wären dann in den submatchtes \tt{1} und \tt{2} gespeichert
und können im Ersetzungstext wieder aufgegriffen werden.

Mit dem senkrechten Strich \tt{e0|e1} wird \tt{e0}
oder \tt{e1} gematcht (der Senkrechtstrich hat die niedrigste Präzedenz).
\tt{foo|bar+} matcht also \tt{foo} oder mindestens ein \tt{bar}.
\tt{(foo|bar)+} dagegen matcht mindestens ein \tt{foo} oder \tt{bar}.

\subsection{Funktionsweise}

Im Kern arbeitet \tt{lga} mit einer Liste von Wörtern
und einer Liste von Lautgesetzen
(in der Form von Textersetzung durch reguläre Ausdrücke)
und wendet der Reihe nach alle Lautgesetze auf die Liste der Wörter an.
Das Resultat sind die Wörter nach Anwendung aller Lautgesetze.

Die Liste der Lautgesetze aber hängt davon ab,
von welcher in welche Sprache die Wörter transformiert werden sollen
und wird aus einem \emph{Baum} von Lautgesetzen und einem
zugehörigen Sprachstammbaum generiert.

Die Liste der Wörter wird vorher durch eine weitere Liste von Regeln,
die von der Ausgangssprache abhängt,
von ihrer graphematischen Form in eine interne phonetische gebracht
(was natürlich eine eindeutige Graphie voraussetzt)
und am Ende durch noch eine Liste von Regeln,
die von der Zielsprache abhängig ist,
wieder in eine graphematische Darstellung gebracht.

Die Funktion \tt{(run-list from to words)}
generiert die drei Listen von Regeln anhand der Sprachen \tt{from} und \tt{to},
macht aus der Liste von Wörtern \tt{words} aus Effizienzgründen einen
einzigen String,
in dem jedes Element von \tt{words} in einer eigenen Zeile steht,
wendet darauf die drei Regellisten an,
und gibt das Ergebnis aus.

Zunächst wird mit der Funktion \tt{(make-path tree start end)} anhand
eines Sprachstammbaums \tt{tree}
eine Liste aller Sprachen von der Ausgangs- zur Zielsprache generiert.
Der Aufruf \tt{(make-path lang-tree 'uridg 'lesb)} würde bspw.
die Liste \tt{(uridg urgr nwgr aiol lesb)} erzeugen.

Der Sprachstammbaum (gespeichert in der globalen Variable \tt{lang-tree})
definiert das Verwandtschaftsverhältnis von Sprachen.
Wenn eine Sprache keine Untersprachen hat,
ist sie (in Scheme-Terminologie) ein Symbol
(also hat z.B. \tt{myk} keine Abkömmlinge).
Hat eine Sprache Untersprachen,
ist sie eine Liste, dessen erstes Element ein Symbol für die Sprache selber ist;
die weiteren Elemente sind Untersprachen (wiederum Symbole oder Listen).
Ein vereinfachter Stammbaum könnte also bspw. folgendermaßen aussehen:
\begin{verbatim}
(urgr (nwgr (dor nwdor sardor sdor)
            (aiol boiot (thess wthess othess) lesb))
      (sogr (ach myk ark kypr pamph)
            (ion-att ion att euboi)))
\end{verbatim}
Es sei angemerkt,
dass die so beschriebenen Verhältnisse nicht streng als Verwandtschaft
interpretiert werden sollten.
Att. und ion. mögen zwar auf ein Urion. zurückgeführt werden,
aber auch nach ihrer Aufspaltung teilen sie noch gewisse Entwicklungen.
Ebenso gibt es gemeingriechische Entwicklung die nach-urgriechisch sind.
Eine präzisere Trennung von Verwandtschaft und ``Sprachgruppen''
würde aber das Modell möglicherweise zu sehr verkomplizieren.
Die beste Möglichkeit ist es womöglich,
auf die Vorsilbe \textit{ur-} zu verzichten und bspw. \tt{gr}
gleichermaßen für urgriechisch und gemeingriechisch zu verwenden
(ebenso wäre statt \tt{urion} besser \tt{ion-att} zu verwenden).

Der Lautgesetzbaum ist eine Liste von vier möglichen Elementen, nämlich
Funktionen, die einen String als Argument nehmen und einen String zurückgeben
(also Funktionen, die Lautgesetze anwenden),
Symbole, die eine Sprachstufe markieren,
und zwei Arten von Listen des Typs \tt{(br/sub lang-lst rule-tree)},
deren zweites Element eine Liste von Sprachen ist,
für die sie gelten (bzw. nicht gelten, wenn das erste Element \tt{not} ist),
und deren drittes Element ein weiterer Lautgesetzbaum ist.
\tt{br} (für \emph{branch}) leitet einen neuen Sprachzweig ein,
der durch \tt{rule-tree} definiert ist
(d.h. dass alle Regeln nach einem erfolgreichen \tt{br} ignoriert werden).
\tt{sub} (für \emph{subrules}) funktioniert ähnlich,
macht aber nach Abarbeitung von \tt{rule-tree}
nach der Regel weiter.
Dies impliziert,
dass es sich hier bei \tt{rule-tree} nicht um einen echten Baum handelt.
\tt{sub} ist nur dazu gedacht eine Liste von Lautgesetzen bedingt anzuwenden.
Im Griechischen ist dies besonders nützlich,
da zwar alle Dialekte ähnliche Entwicklungen machen,
diese sich aber im einzelnen unterscheiden.
Mit \tt{sub} kann man einfach Regeln für bestimme Dialekte oder
Dialektgruppen definieren ohne für jeden Dialekt einen eigenen Sprachzweig
haben zu müssen.

Die Funktion \tt{(make-rules tree path)}
gibt anhand des Lautgesetz\emph{baums} \tt{tree} eine \emph{Liste}
von Lautgesetzen zurück,
die die Sprachentwicklung in \tt{path} (von \tt{make-path} erzeugt, s.o.)
reflektiert.
Von \tt{(apply-rules rules words)} wird dann diese Liste \tt{rules}
auf die Wörter \tt{words} angewandt.

Die Lautgesetzfunktionen werden von der Funktion \tt{(s pattern . subst)}
erzeugt,
die aus einem String \tt{pattern} einen regulären Ausdruck macht
und eine Funktion zurückgibt,
die \tt{irregex-replace/all} auf diesen regulären Ausdruck
und die Ersetzungen in der Liste \tt{subst} anwendet.
Matcht der reguläre Ausdruck einen Teil der Eingabe,
wird diese durch \tt{subst} ersetzt,
dessen Elemente Strings, Zahlen als Indizes der Submatches, sowie
Funktionen, die anhand eines Matches Strings zurückgeben, sind.
\tt{(irregex-replace/all "(foo)(bar)" "foobar" 2 (lambda (m)
    (string-reverse (irregex-match-substring m 1))) "quux")}
z.B. würde den String \tt{"foobar"} durch \tt{"baroofquux"} ersetzen.

Die oben beschriebenen regulären Ausdrücke
sind für die Modellierung von Laugesetzen nicht ausreichend.
Neben anderen Unzulänglichkeiten,
die sich im Laufe der Arbeit herausstellen werden,
gibt es eindeutig Probleme, mit Lautklassen umzugehen,
und noch allgemeiner, Laute durch Zeichen zu kodieren.

Wenn jeder Laut durch genau ein Zeichen bzw. einen Unicode Codepoint kodiert wird,
gibt es der Lautkodierung keine Probleme.
Da es allerdings sinnvoll ist,
einige Laute mit mehreren Codepoints zu kodieren,
kann es zu Problemen kommen.
Will man bspw. ein Lautgesetz \tt{(s "b" "p")} formulieren,
so hätte dies die Nebenwirkung,
dass auch \tt{bʰ} zu \tt{pʰ} würde,
was im allgemeinen Fall unerwünscht ist.
Wenn man Laute wie \bel{bʰ} oder \bel{gʷ} mit einem einzigen Codepoint
repräsentieren würde,
hätte man dieses Problem natürlich zwar nicht,
jedoch bietet Unicode für solche Vorhaben keine definierten Codepoints.
Dafür müsste man die Private Use Area benutzen,
wodurch die Kodierung jedoch von der Schriftart abhängig wird:
eine unschöne Lösung.
In der hier entwickelten Version von \tt{lga} wird das Problem nicht gelöst.
Stattdessen müssen die Lautgesetze vorläufig
besonders vorsichtig formuliert werden,
der obere Fall also als \tt{(s "b([\textasciicircum{}ʰ])" "p" 1)}.

Bei der Formulierung von Lautgesetzen ist es ferner sinnvoll,
Laute in Lautklassen zusammenzufassen um eine konzise
und leicht abstrahierende Darstellung zu haben.
Der POSIX Standard definiert zwar Zeichenklassen wie \tt{[:digit:]}
für Ziffern oder \tt{[:lower:]} für Kleinbuchstaben,
aber die Bedürfnisse, die man als Linguist hat,
sind damit nicht abgedeckt,
da sich zur Laufzeit Zeichenklassen weder neu definieren noch verändern lassen.
Dieses Problem lässt sich vorläufig lösen,
indem die regulären Ausdrücke,
bevor sie von \tt{string->irregex} in eine interne Form kompiliert werden,
noch verändert werden,
so dass die tatsächlich im Quelltext vorkommenden regulären Ausdrücke
erst zu echten regulären Ausdrücken verarbeitet werden,
die von der \tt{irregex}-Engine verstanden werden.
Konkret funktioniert dies so,
dass in einer assoziativen Liste Lautklassennamen (als Symbole)
mit Strings assoziiert werden
und bei der Vorbearbeitung der regulären Ausdrücke
Strings der Form \tt{<lautklassenname>} durch den mit dem Symbol
\tt{lautklassenname} assoziierten String ersetzt werden.
Die Funktion \tt{(set-class key value)} assoziiert den Namen \tt{key}
mit dem String \tt{value} und \tt{(l key)} (kurz für \emph{lookup})
findet den zu \tt{key} passenden String in der assoziativen Liste.

So kann man bspw. mit \tt{(set-class 'kurz-vok "a|e|i|o|u")} und
\tt{(set-class 'lang-vok "ā|ē|ī|ō|ū")} Kurz- und Langvokale definieren,
mit \tt{(set-class 'vok (s+ (l 'kurz-vok) "|" (l 'lang-vok)))} dann die Menge
aller Vokale
(\tt{s+} ist eine Abkürzung für \tt{string-append} zum Verketten von Strings)
und diese in einem Lautgesetz wie \tt{(s "<vok>" "a")} verwenden.

Die Lautklassen sind jedoch zur Laufzeit nicht vernünftig veränderbar,
da sie zur Zeit der Auswertung von \tt{s} in den regulären Ausdruck
eingefügt werden,
man die Definition aber wohl am ehesten aus dem Lautgesetzbaum heraus
verändern wollen würde.
Hier wird nur eine neuentwickelte Lautgesetzengine wirklich
Abhilfe schaffen können.

Es gibt jedoch noch ein weiteres Problem.
So kann man nicht ohne weiteres z.B. einen Langvokal durch seinen
entsprechenden Kurzvokal oder einen silbischen durch sein unsilbisches
Pendant ersetzen.
Beispiele für solche Vorgänge gibt es genug und es ist eine Methode notwendig,
mit der man diese Fälle unkompliziert ausdrücken kann.
In einer späteren Version wäre vielleicht eine Ersetzung wie
\tt{(s "<lang-vok>" "<kurz-vok>")} wünschenswert,
in der aktuellen Version können jedoch auch Funktionen,
die auf Submatches angewandt werden, denselben Effekt erzielen.
Als Ersetzungsargumente kann man an \tt{irregex-replace/all}
neben Strings und Zahlen, die das entsprechende Submatch bezeichnen,
auch Funktionen übergeben,
die auf das aktuelle Match angewandt werden und einen String zurückgeben.
Um also z.B. einen Langvokal in ein Kurzvokal zu verwandeln,
braucht es nur eine Funktion,
die auf ein Submatch eine Reihe von regulären Ausdrücken anwendet
und das Ergebnis zurückgibt.
Eine Funktion, die reguläre Ausdrücke auf einen String anwendet,
gibt es ja schon: \tt{apply-rules}.
Diese wird von der Funktion \tt{(match-rulelist rules)} benutzt,
die eine Liste von Ersetzungsfunktionen \tt{rules}
auf ein Submatch anwendet.
Dazu gibt sie eine Funktion zurück,
die einen Submatchindex \tt{i} bindet und eine Funktion zurückgibt,
auf die \tt{irregex-replace/all} angewandt werden kann.
Die Vokalkürzung könnte somit folgendermaßen definiert werden:
\begin{verbatim}
(define kuerzung
  (match-rulelist
    (list (s "ā" "a")
          (s "ē" "e")
          (s "ō" "o")
          (s "ī" "i")
          (s "ū" "u"))))
\end{verbatim}
Ein Lautgesetz, das alle Langvokale kürzt,
könnte dann als \tt{(s "(<lang-vok>)" (kuerzung 1))} formuliert werden.

Die eingangs erwähnten Regellisten zur Umwandlung von einer
graphematisch/phonologischen in eine phonetische und von
einer phonetischen in eine graphematisch/phonologische Darstellung
sind unter ihrem Sprachnamen ebenfalls in
assoziativen Listen abgelegt.

Hiermit ist die Funktionalität von \tt{lga} weitestgehend erläutert.
Eine genauere Beschreibung kann natürlich nur der Quelltext selber liefern.

\section{Modellierung der Lautentwicklung des Altgriechischen}
\subsection{Vorbemerkungen}
Vor der Beschreibung der Lautentwicklung noch einige Anmerkungen,
die nicht speziell das Griechische betreffen.
Aufgrund von Fehlern in der Implementation von \tt{irregex}
können in regulären Ausdrücken keine höheren Unicodezeichen
in \tt{[]}-Sets benutzt werden.
Da diese aber notwendig sind, um gewisse Zeichen auszuschließen
-- insbesondere \tt{ʰ} zur Unterscheidung von Aspiraten --
müssen diese aus dem ASCII-Vorrat stammen.
Aus dem Grund wird für die Aspiration \tt{!} statt \tt{ʰ} verwendet.
Eigentlich wäre wie schon oben beschrieben für Aspiraten oder sonstige Laute,
die mit mehreren Codepoints ausgedrückt werden,
ein einziger Codepoint
oder eine Möglichkeit, mehrere Codepoints als ein Zeichen zu behandeln,
praktischer und angemessen,
aber da ersterer Fall, wie ja schon angemerkt, nicht von Unicode
abgedeckt wird, wäre man dann von der Schriftart abhängig,
und der zweite Fall wird von \tt{irregex} nicht unterstützt.
Für die Labiovelare wurden im Gegensatz zu den Velaren Großbuchstaben verwendet,
um dieses Problem zu vermeiden und auch
die silbischen Resonanten \bel{r̥l̥m̥n̥} werden mit den Großbuchstaben \tt{RLMN} ausgedrückt.
Die Halbvokale \bel{i̯u̯} werden mit \tt{yw} und
die Laryngale \bel{h[₁₂₃]} mit \tt{H[123]} bezeichnet.
Akzente werden in der graphematischen Schreibweise
als combining diacritics geschrieben und intern mit \tt{'} und \tt{\textasciitilde}
bezeichnet.

Die Umwandlung dieser graphematischen Schreibungen in die interne
(mehr oder weniger phonetische) Darstellung geschieht in der Liste der
phonologischen Regeln für \tt{uridg} (in \tt{rules.scm}).

Als weitere (echte) phonologische Regeln für das Uridg.
sind Laryngalumfärbung (\rek{e} neben \rek{h₃} jedoch noch von \rek{o}
verschieden, was allerdings für das Gr. belanglos ist)
und Stimmhaftwerdung von \rek{s} neben stimmhaften Konsonanten beschrieben.
Weitere phonologische Regeln müssen ggf. ergänzt werden.
Lautgesetze wie \textsc{Stang}s Gesetz,
die vor dem Erreichen des Sprachzustandes, der mit \tt{uridg} bezeichnet wird,
durchlaufen wurden,
wurden nicht berücksichtigt und die Rekonstrukte bzw. Transponate,
die als Eingabe dienen, sollten einen entsprechenden Lautstand vorweisen
(um bei \textsc{Stang}s Gesetz zu beleiben wäre also \rek{di̯ēm} nicht \rek{di̯eu̯m} \tt{uridg}).
Insbesondere enthält \tt{uridg} den \textit{þ}-Laut,
dessen Herkunft und Phonetik hier ebenfalls nicht weiter hinterfragt wird.

Im Folgenden werden die Lautgesetze vom Urindogermanischen ins Griechische
in drei Etappen aufgestellt.
Zunächst wird die Lautentwicklung bis ins Urgriechische modelliert,
dann bis und in mykenischer Zeit und schließlich in die Dialekte
der alphabetischen Zeit.
Die dazu verwendete Literatur ist im wesentlichen \cite{rix}, \cite{bart_hand},
\cite{bart_frueh}, \cite{sihler}.

Eine (relative) Chronologie aller Lautgesetze lässt sich nicht immer
mit Sicherheit aufstellen,
da viele Lautgesetze kaum mit anderen Lautgesetzen interagieren
oder mehrere Entwicklungen denkbar sind,
so dass man gerade in der frühesten Zeit,
in der das Griechische noch nicht belegt ist,
in diesen Fällen wenig mehr als nur raten kann.
Hier werden dann die Lautgesetze entweder mit ähnlichen
anderen Gesetzen oder nach Gefühl einsortiert.

Auch ist die Aufstellung hier keinesfalls als endgültig anzusehen.
Die Details vieler Lautwandel würden oft einer genaueren Untersuchung bedürfen,
die den Rahmen dieser Arbeit sprengen würden.
Sowohl das Programm \tt{lga} als auch die Formulierung
der Lautgesetze sind somit als vorläufige Ergebnisse zu sehen,
auf denen weitere Arbeiten aufbauen sollen.

\subsection{Urindogermanisch bis Urgriechisch}

Die Lautveränderung,
die ins Urgr. führen, sind grob gesprochen
die Kentumvertretung der Tektale,
\rek{sT} als Reflex von \rek{TT},
die Entwicklung von \rek{þ},
jegliche Laryngalentwicklungen,
die Entwicklung der silbischen Resonanten (teilweise aber auch erst dialektal),
die Stimmloswerdung der Mediae aspiratae,
einige Okklusivassimilationen,
die Entwicklung von \rek{s}
und die Anfänge diverser Palatalisierungen.

\mypara{Kentum}
Das Griechische ist eine Kentumsprache,
es fallen also die uridg. Palatale mit den Velaren zusammen.
(Rix §92-94)

\mypara{\rek{TT} > \bel{sT}}
In der Verbindung zweier Dentale wird der erste zu urgr. \rek{s}.
(Rix §106c)

\mypara{*MA > TA}
Mediae aspiratae werden zu Tenues aspiratae
(Rix §94).
Aufgrund der Nähe zum Makedonischen und Phrygischen
ist dieser Wandel vielleicht später anzusetzen.

\mypara{\rek{(H)i̯-}}
Da es im Gr. scheinbar zwei Vertretungen von \rek{i̯-} gibt,
versucht man mit der Laryngaltheorie die beiden Reflexe als \rek{Hi̯-}
und \rek{i̯-} zu unterscheiden.
Welcher Anlaut zu urgr. \rek{dz-} verschärft wurde,
ist unklar -- nach Rix §68,80e ist es \rek{Hi̯-} --
und nach dem Datenmaterial kann für beides argumentiert werden.
Eine lautlich plausible Lösung ist
frühe Verschärfung von uridg. \rek{i̯-} zu urgr. \rek{dz-}
(vielleicht über Zusammenfall mit ererbtem \rek{di̯-},
das ebenfalls zu \rek{dz-} wird),
danach Wegfall aller Laryngale (also keine Vokalisierung wie vor \rek{u̯}),
wodurch \rek{Hi̯-} als \rek{i̯-} stehenbleibt,
wie es im Frühmyk. belegt ist.

\mypara{Laryngale}
\label{laryngale}
Die Entwicklung der Laryngale folgt Rix §79-85.
Teilweise sind die Lautgesetze weniger explizit als bei Rix formuliert,
um eine lautlich plausiblere Entwicklung zu modellieren.
So wird z.B. intervokalischer Laryngal nach \rek{i} oder \rek{u}
nicht zum Gleitlaut sondern dieser entsteht erst als Hiattilger
nach dem Laryngalschwund.

\mypara{\rek{u̯eu̯} > \bel{u̯ei̯}}
\rek{u̯eu̯} wird zu \rek{u̯ei̯} dissimiliert,
wie εἶπον < \rek{e-u̯e-u̯kʷ-om} (vgl. ai. \bel{avocam}) lehrt.
Dies muss ferner vor \ref{labvel-vel} passieren,
wie εἶπον ebenfalls zeigt.

\mypara{Labiovelar > Velar}
\label{labvel-vel}
Neben \rek{ū̆}, \rek{u̯} und vor \rek{i̯}
fallen die Labiovelare mit den Velaren zusammen (Rix §97).

\mypara{Silbische Resonanten}
Die Entwicklung der silbischen Resonanten folgt Rix §75 und §76.
Für das Urgr. wird ein Sprossvokal \rek{ə} angesetzt,
welcher sich dialektal zu \bel{a} oder \bel{o} entwickelt.

Genauere Datierung unklar.

\mypara{Nasal vor Okklusiv}
Vor Okklusiven wird der homorgane Nasal realisiert (Rix §78).
Gegen Rix jedoch nicht \rek{ms} > \rek{ns} wegen
ἔνειμα < \rek{enemsa}.
Hier kann \bel{m} zwar analog wieder eingeführt worden sein,
aber ohne ein Beispiel, das bei Rix fehlt, ist die Regel zunächst unnötig.
Die Nasalassimilation passiert auch später noch und
dürfte tatsächlich wohl über lange Zeit eine synchrone phonologische Regel sein.

\mypara{\rek{m} > \rek{n} \textbackslash\ \rek{i̯}}
Rix §77.
Datierung unklar.
Vielleicht nach \rek{m̥} > \rek{am}, aber \rek{m̥} > \rek{n̥} \textbackslash\ \rek{i̯}
ist ebenfalls als zusätzliche Regel denkbar.

\mypara{Benachbarte Vokale nach Laryngalschwund (1. Kontraktion)}
Kontraktion von \rek{e}, \rek{a}, \rek{o},
zwischen denen Laryngal geschwunden ist (Rix §81).
Datierung unklar.

Nach Vokal werden \rek{i}, \rek{u} zu Halbvokalen (es entstehen also Diphthonge).
Im umgekehrten Fall entsteht ein Gleitlaut zwischen den beiden Lauten.

\mypara{Thorn}
\rek{þ} (genauer Lautwert unklar) tritt nach Velaren und Labiovelaren auf.
Nach Tenues ist entsprich \bel{t}, nach Aspirata \bel{tʰ}
(Rix §81).

\mypara{\textsc{Osthoff}}
\label{osthoff}
\textsc{Osthoff}s Gesetz kürzt Langvokale vor tautosyllabischem
Resonanten (Rix §64).
Im Auslaut ist die antevokalische Sandhivariante verallgemeinert
und Langvokale bleiben erhalten.
Nach Laryngaldehnung (\ref{laryngale}) und vor Okklusivverlust im Auslaut
(\ref{konsausl}) zu datieren,
wie z.B. hom. ἔσταν < \rek{estānt} < \rek{e-steh₂-n̥t} zeigt.

\mypara{Konsonanten im Auslaut}
\label{konsausl}
Wortauslautende Okklusive gehen verloren (Rix §100).
Dies muss nach der Vokalisierung der silbischen Liquiden passiert sein,
da ὑπόδρα < \rek{upodrak} < \rek{upodr̥k̑} den auslautenden Konsonanten
voraussetzt.
Außerdem nach \textsc{Osthoff} (\ref{osthoff}) wie dort gezeigt.

Auslautendes \rek{m} erscheint als \bel{n} (Rix §77).

Genauere Datierung in beiden Fällen unklar.

\mypara{Okklusivassimilation}
Okklusive werden an folgende Okklusive in
Aspiration und Stimmhafigkeit assimiliert (Rix §106a).

Hier dürfte es sich wohl eigentlich um eine phonologische Regel handeln.

\mypara{Beseitigung von Geminaten}
\label{gem}
Wie das Uridg. muss auch das Gr. eine Zeit lang Geminaten vermieden haben
(vielleicht nur nach Langvokal/Diphthong?),
wie αἰπόλος < \rek{ai̯kʷolos} < \rek{ai̯g-kʷolos} zeigt.
Weitere Beispiele könnten die Verhältnisse klarer machen.

Datierung unklar,
möglicherweise handelt es sich hier um eine phonologische Regel
(die in späterer Zeit jedoch nicht mehr gilt).

\mypara{\rek{ku̯} > \rek{kʷ}}
\rek{ku̯} > \rek{kʷ} (Rix §104).
Statt Gemination im Inlaut, wie Rix schreibt,
scheint eine Erhaltung des Silbengewichts wahrscheinlicher
(also nur nach Kurzvokal im Inlaut).
Durch Mangel an Beispielen lässt sich aber wohl kaum genaueres sagen.

Wenn die Beseitigung der Geminaten (\ref{gem}) allgemein war,
muss die Gemination hier später sein.
Wenn sie hingegen nur überschwere Silben (also Langvokal/Diphthong + Geminate)
betraf,
ist die Datierung gänzlich unklar.

\mypara{Assimilation über \bel{s}}
Eine Tenuis hinter \rek{s} wird an eine vor \rek{s} stehende
Media oder Tenuis aspirata in ihrer Artikulationsart angeglichen (Rix §105).

Auf jeden Fall vor \ref{okklu-s} wegen πάσχω < \rek{pʰatʰskō},
λέσχη < \rek{lekʰskā}, μίσγω < \rek{migskō}.

\mypara{CsC > sC}
Steht \rek{s} zwischen zwei gleichen Okklusiven, schwindet der erste.
Nasal vor \rek{s} und Konsonant schwindet ebenfalls (Rix §87c).

Datierung etwas unklar, da der Nasalschwund später noch mal stattfindet
(σύζυγος < \rek{sun-zdugos} < \rek{sun-dzugos}.

\mypara{Cs}
\label{okklu-s}
Vor \bel{s} werden Okklusive zu Tenues (Rix §105).

\mypara{\rek{s} > \rek{h}}
\rek{s} > \rek{h} vor Vokal oder Resonant oder zwischen Vokalen (Rix §86,89).
Vor \rek{m} ist \rek{s} jedoch (sogar im selben Wort) teilweise erhalten.

Datierung unklar.

\mypara{\rek{s} neben \rek{i̯}}
Nach Rix §89g ist \rek{s} neben \rek{i̯} über \rek{h} assimilert worden.
Die Beispiele belegen jedoch nur eine Assimilation bei \rek{si̯}
und der Weg über \rek{h} scheint nur aus systematischen Gründen gewählt zu sein.

Tatsächlich gibt es nämlich Probleme wenn man die Dat.Pl. Endung -οισι
lautgesetzlich aus \rek{-oi̯si} erklären möchte.
Daher wird hier auf die Annahme einer Assimilation bei \rek{i̯s} verzichtet.

Datierung unklar.

\mypara{Palatalisierung}
Die Anfänge der Palatalisierungen liegen wohl in urgr. Zeit
und die genaue Entwicklung in den Dialekten ist kompliziert.
Zu diesem Thema siehe Allen 1958, Rix §102,103 und Bartoněk S. 140ff.

Linear B hat zwei Reihen für die Schreibung der Zischlaute,
deren Konsonanten mit <z> und <s> transliteriert werden.
Welche Laute mit diesen Zeichen bezeichnet wurden ist unklar.
Oft wird <s> als einfacher Sibilant und <z> als Affrikate verstanden,
jedoch ist es sehr gut möglich,
dass es sich tatsächlich um einen Unterschied der Palatalität handelt
und beide Zeichenreihen sowohl Sibilanten als auch Affrikaten bezeichnen können.
die Z-Reihe würde dann einen palataleren Laut als die S-Reihe bezeichnen.
Mit dieser Annahme lassen sich die mykenischen Schreibungen
und die Lautentwicklung zufriedenstellend erklären,
wie sich noch zeigen wird.

Dentale Tenuis (aspirata) + \rek{i̯} im Anlaut ergibt in allen Dialekten \bel{s},
das wohl als urgr. gelten darf.
Im Inlaut wird hier \rek{ts} angesetzt, das mit altem \rek{ts} zusammenfällt
und sich dann dialektal unterschiedlich entwickelt.
In Linear B wird für diesen Laut die S-Reihe benutzt,
weswegen eine palatale Qualität sehr unwahrscheinlich ist.

Dieselbe Lautkombination an morphologisch transparenter Stelle
ergibt einen anderen Laut,
der in alphabetischer Zeit mit dem Resultat der Palatalisierung der
Velare zusammenfällt,
in Linear B aber mit der S-Reihe geschrieben wird.
Vielleicht wurde an dieser Stelle das \rek{i̯} restituiert
und die Gruppe \rek{tsi̯} nachmyk. weiterpalatalisiert,
so dass sie mit Resultat der palatalisierten Velare zusammenfiel.

\rek{di̯}, \rek{gi̯} > \rek{dž}.
Da der hier entstehende Laut in Linear B mit der Z-Reihe geschrieben wird,
dürfte dieser Laut palatal gewesen sein.
Die genaue Phonetik ist offensichtlich dunkel.

Velare Tenuis (aspirata) + \rek{i̯} scheint eine spätere Palatalisierung
als die der Dentale zu sein.
Das Ergebnis wird in Linear B ebenfalls mit der Z-Reihe geschrieben,
was eine stimmlose Version des obigen Lautes nahelegt,
also \rek{tš}.

Labial + \rek{i̯} ergibt \bel{pt} in allen Dialekten,
muss jedoch eine Vorstufe urgr. \rek{pč} gehabt haben,
da das Myk. ein eigenes Zeichen für diesen Laut kennt,
der erst später auch für ererbtes \bel{pt} verwendet wird.
%TODO: artikel dazu

Die Resonanten \rek{l}, \rek{r}, \rek{n}
(\rek{m} in dieser Position schon mit \rek{n} zusammengefallen)
werden vor \rek{i̯} zu palatalisierten Geminaten.
Ob hier Anlaut oder Silbengewicht eine Rolle spielen, ist noch zu überprüfen.

\mypara{\rek{dl} > \rek{ll}}
Datierung unklar.

\mypara{Metathese von \rek{t} und (Labio)velaren}
Nach Rix (§106) werden \rek{tk} und \rek{tp} metathetiert.
Für \rek{tp} > \rek{pt} gibt er als Beispiel \rek{kʷid-pe} > τίπτε,
das aber wohl besser als \rek{kʷid-kʷe} > \rek{kʷikʷte} > τίπτε zu erklären ist.
Daher wird hier zunächst aus Mangel an Beispielen nur eine Metathese von
\rek{t} und (Labio)velaren angenommen.

Datierung unklar.

\subsection{Urgriechisch bis mykenische Zeit}

In diesem Abschnitt wird die Lautentwicklung bis zur Zeit,
in der die mykenische Überlieferung endet, modelliert.
Am Anfang dieser Zeit steht die erste dialektale Aufspaltung.
Da außer dem recht einheitlichen myk. Dialekt keine weiteren aus dieser
Zeit überliefert sind,
wird der Lautstand des Myk.
-- sofern es keinen Grund gibt, etwas anderes anzunehmen --
als repräsentativ für das gesamte gr. Sprachgebiet gesehen.

Die dialektale Gliederung ist aus \cite{bart_frueh} Tab. B genommen
und sieht in Scheme wie folgt aus:
\begin{verbatim}
(urgr (nwgr (dor nwdor sardor sdor)
            (aiol boiot (thess wthess othess) lesb))
      (sogr (ach myk ark kypr pamph)
            (ion-att ion att euboi)))
\end{verbatim}

\mypara{\rek{ti} > \bel{si}}
Dieser Lautwandel wird als grundlegende Unterscheidung zwischen Südost-
und Nordwestgriechisch gesehen,
ist aber weniger Lautgesetz als einem lieb wäre (Rix §101).
Auch westgr. Dialekte haben \bel{si} in \emph{ti}-Abstrakta
und das Myk. geht in \bel{ko-ri-si-o} weiter als andere Dialekte,
die alle Κορίνθιοι zeigen (\cite[144]{bart_hand}).
Hier wird der Lautwandel wegen z.B. ἔστι, κτίσις
nach \bel{s} und \bel{k} ausgesetzt
Eine genauere Lautumgebung -- falls man sie überhaupt angeben kann --
ist unsicher.
Vermutlich ist der Wandel schlicht nicht lautgesetzlich
sondern als eine Verallgemeinerung von Sandhivarianten zu sehen
(und somit Analogie).

\printbibliography

\end{document}
